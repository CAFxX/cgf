#include "CGF.h"

CGFCallSite::CGFCallSite(CGF *cgf, CallInst *cs) : c(cgf), s(cs), prepared(false), flattened(false) {
    assert(cs->getCalledFunction() != NULL && "Indirect callsite");
    assert(cs->getCalledFunction() != cs->getParent()->getParent() && "Direct recursive callsite");
    // FIXME FIXME FIXME detect indirect recursion!!!
}

void CGFCallSite::prepare() { 
    TRACE();
    assert(!prepared && "Already prepared");
    assert(!flattened && "Already flattened");

    // split the return BB
    splitRetBB();

    // get the list of possible call targets
    // XXX currently only direct call targets are supported
    Parent = c->funcs.find( s->getParent()->getParent() )->second;
    assert(s->getParent()->getParent() == Parent->f);
    Parent->registerCallee(this);

    CGFFunction *f = c->funcs.find( s->getCalledFunction() )->second;
    assert(f!=Parent);
    f->registerCaller(this);
    //Callees.push(f);
    Callee = f;

    // get the arguments
    for (unsigned i=0; i<s->getNumArgOperands(); i++) {
        Args.push_back(s->getArgOperand(i));
    }

    // get the return values
    // XXX only a single return value is supported
    RetVal = s;

    prepared = true;
}

void CGFCallSite::flatten() {
    assert(prepared && "Not prepared");
    assert(!flattened && "Already flattened");

    assert(s->getParent()->getParent() == c->dispatch);
    // FIXME: handle indirect calls
    BranchInst *callinst = BranchInst::Create(Callee->innerDispatch);
    ReplaceInstWithInst(s->getParent()->getTerminator(), callinst);

    for (unsigned j=0; j<Args.size(); j++) {
        Callee->argphis[j]->addIncoming(Parent->vmap[Args[j]], s->getParent());
    }
    Callee->retphi->addIncoming(BlockAddress::get(RetBB), s->getParent());
    Callee->retinst->addDestination(RetBB);

    Value *newRetVal = go_fetch(Callee->retVal, RetBB);
    assert(newRetVal);
    s->replaceAllUsesWith(newRetVal);
    s->eraseFromParent(); // s==RetVal

    flattened = true;
}

void CGFCallSite::splitRetBB() {
    BasicBlock *parent = s->getParent();
    for (BasicBlock::iterator i = parent->begin(), ie = parent->end(); i != ie; i++) {
        if (&*i == s) {
            RetBB = SplitBlock(parent, ++i, c->p);
            assert(RetBB != NULL && "Can't split BB - SplitBlock returned NULL");
            RetBB->setName(parent->getName());
            statCanonicalizedCallsites++;
            return;
        }
    }
    assert(!"Can't split BB");
}



